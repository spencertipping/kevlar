sdocp('sdoc::js::kevlar.client.jquery', 'Kevlar jQuery RPC client | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nThere are two modes of client operation. By default, kevlar uses a blocking AJAX connection to retrieve the RPC list; this automatically configures the client-side RPC endpoints to give you\nnamed methods. However, sometimes you don\'t have the luxury of blocking the UI thread this way. In that case you can create a non-auto RPC endpoint.\n\nAll methods are attached to a global named kevlar. Like caterwaul, the kevlar global gives you a deglobalize() method to restore the original global.\n\nNote that this module expects a global JSON object to be available. This can be enabled by loading json2.js from json.org, or by using a modern browser that provides native JSON serialization\nand parsing.\n\ncaterwaul.js_all()(function (original_kevlar) {\n  kevlar(xs = arguments) = kevlar -effect- xs *![create_rpc_endpoint_for(x)] /seq,\n  kevlar.deglobalize()   = kevlar -re [kevlar = original_kevlar],\n\n  kevlar.auto(cc)        = bind [result = kevlar] in $.ajax({async: !cc, url: \'/kevlar/rpc-map\', type: \'POST\', data: \'[]\'}).complete(cc || given.rpcs [result = rpcs[0]]) -re- result,\n\n  where [create_rpc_endpoint_for(name)       = kevlar[to_javascript_identifier(name)] = rpc_thunk_for(name),\n         rpc_thunk_for(name)(xs = arguments) = $.ajax({type: \'POST\', url: \'/#{name}\', data: JSON.stringify(xs), success: callback})\n                                               -where [callback = xs[xs.length - 1] -re [it && it.constructor === Function ? xs.pop() : undefined]],\n\n         to_javascript_identifier(s)         = s.replace(/[^A-Za-z0-9_$]/g, \'_\').replace(/_+/g, \'_\')]})(typeof kevlar === \'undefined\' ? undefined : kevlar);\n');